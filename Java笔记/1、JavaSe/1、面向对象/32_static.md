[TOC]
# Static

关键字，代表静态

可以修饰变量，方法，代码块，内部类

如果四个同时出现，按代码从上往下的顺序执行，存在方法区内，可以修改，有共享性。

## 一、static关键字的基本用法

注意：

1. static修饰的成员变量和方法，属于类
2. 普通变量和方法从属于对象
3. 静态方法不能调用非静态成员，编译会报错。

### 1、static关键字的基本概念

概括：方便在没有创建对象的情况下进来调用。

即：被static关键字修饰的不需要创建对象去调用，直接根据类名就可以去访问。对于这个概念，下面根据static关键字的四个基本使用来描述。

### 2、static关键字用法

#### 2.1 static关键字修饰内部类

Java里边的static一般用来修饰成员变量或函数。但有一种特殊用法是用static修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。

```Java
/**
 * static关键字：修饰内部类
 */
public class NmnblStatic {
    //静态内部类
    static class B{
        public B(){
            System.out.println("静态内部类...." );
        }
        public void productB(){
            System.out.println("静态内部方法.....");
        }
    }

    public static void main(String[] args) {
        B b=new NmnblStatic.B();
        b.productB();
    }
}
    /**
     * 输出是：
     *  静态内部类....
     *  静态内部方法.....
     */
```

如果没有用static修饰B，则只能new一个外部类实例。再通过外部实例创建内部类。

#### 2.2 static关键字修饰方法

static修饰方法即可

生命周期：随着类加载而加载到方法区的静态区中，在被调用时才开始运行。

调用格式：类名.静态方法名()/对象名.静态方法名()，例如：Arrays.toString()  Arrays.copyOf()

注意：

1. 静态方法中能否定义静态变量？

   不可以，随着类加载而加载到方法区的静态区中，只是存储方法并未执行该方法，在被调用时才开始运行。静态变量是在类加载时加载到静态区并且初始化

2. 静态方法中能否直接调用非静态方法。  

   不可以，非静态方法和非静态变量必须得通过对象来调用，而当我们使用类名来调用静态方法时，可能根本没有创建对象。如果想调用可以在调用非静态方法必须创建对象调用，通过对象调用非静态方法。

3. 静态方法中是否可以用this、super这俩关键字

   不可以，this指代当前对象super指代当前父类的对象，没有对象，他俩都不能使用

4. main方法中是否能用this super?

   不能 main方法是静态方法

5. 静态方法能否重载？

   可以

6. 子类能否继承父类的静态方法？

   可以继承父类的静态方法

7. 子类能否重写父类的静态方法？

   不能重写，静态方法和类绑定

8. 子类中能不能存在和父类方法签名等都一致的静态方法？

   可以

```java 
public class StaticMethod {
    public static void run() {
        System.out.println("run.....");
    }

    public static void main(String[] args) {
        //方式一： 直接通过类名获取
        StaticMethod.run();
        //方式二：
        StaticMethod staticMethod=new StaticMethod();
        staticMethod.run();
    }
}
```

#### 2.3 static关键字修饰变量

被static修饰的成员变量叫做静态变量（存在于静态区），也叫做类变量，说明这个变量属于这个类的，而不是属于对象，没有被static修饰的成员变量叫做实例变量，说明这个变量属于某个具体的对象的。

生命周期：类加载之后不再移除，直到整个程序运行结束，静态变量随着类加载被加载到方法区的静态区中，直到类被移除才会释放。

调用格式：类名.静态变量名/对象.静态变量名；以上两种方式Java都支持，但是为了提高程序的可读性，建议使用通过雷鸣来调用静态变量。

应用场景：

1. 静态变量：如果每个对象有各自的特征点，不适用static修饰，如果每个对象的特征值都一样则可以使用static修饰。
2. System.in 和System.out  in out 就是 静态变量。

注意：

1. 在构造代码块当中可以定义静态代码块吗？

   不可以，类加载之后才能创建对象，构造代码块在创建对象时执行，静态代码块是在类加载时就要初始化。

2. 在构造方法中可以定义静态变量吗？

   不可以，类加载之后才能创建对象，构造方法在创建对象时调用，静态代码块是在类加载时就要初始化

3. 能否在构造代码块或者构造方法中给静态变量赋值？

   可以

```java 
public class StaticVar {
    static String var1="aa";

    public static void main(String[] args) {
        System.out.println(StaticVar.var1);
    }
}
```

#### 2.4 static关键字修饰代码块

格式：

  static {

}

执行：

 在类真正被使用时会执行静态代码块；仅执行一次；

创建类的对象

调用类的静态方法。

调用类的静态属性

 在类加载时被调用(辩证理解 Person.class时不会输出静态代码块)

注意：

1. 静态代码块中能否定义静态变量？

   不可以，静态变量在类加载时初始化。代码块在类真正被使用时才执行静态代码块

2. 静态代码块中能不能给静态变量赋值？可以

3. 静态代码块 构造代码块 构造方法的执行顺序？

   静态代码块-->构造代码块 -->构造方法

4. 基于父子类时静态代码块 构造代码块 构造方法的执行顺序？

   父类的静态代码块--》子类的静态代码块--》父类构造代码块--》父类构造方法--》子类构造代码块--》子类构造方法

 先父后子，先静态再动态，先构造代码块再构造方法

基于父子类并且子类中定义了（引用类型的属性）属性，创建类对象时，属性初始化和构造代码块执行的顺序取决于程序的顺序。

基于父子类然后父类中定义了属性，也按先后顺序执行

有静态变量和静态代码块时要取决于代码的顺序。

```Java
class A{
	{
		i = 5;
	}
	int i;
class B{
static{
      i=7;//编译正确，但是不能使用，使用的话会报错
}
static int i;
}
```

![](https://note.youdao.com/yws/api/personal/file/0E4A5478256A49E5B6970D927ECE91F2?method=download&shareKey=03a284e4cd2a09856db7db8f5e3dc34b)

## 二、深入分析static关键字

 ![](https://pics3.baidu.com/feed/024f78f0f736afc33409f1471839eec1b74512b4.jpeg?token=33db0ecbe211c671b69179720b8e41d4&s=ED9CAA528ACE3EC846392E6303003066) 

从上图我们发现，静态变量存放在方法区中，并且是被所有线程所共享的。

堆区：

1. 存储的全部是对象，每个对象都包含一个与之对应的class信息。(class的目的是得到操作指令)
2. jvm只有一个堆区(heap)被所有的线程所共享，堆中不存放基本类型和对象引用，只存放对象本身。

栈区：

1. 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中。
2. 每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。
3. 栈分为3个不分：基本类型变量区，执行环境上下文，操作指令区(存放操作指令)。

方法区：

1. 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
2. 方法区中包含的都是在整个程序中唯一的元素，如class，static变量。

## 三、static关键字小结

### 1、static特点

1. static是一个修饰符，用于修饰成员（成员变量，成员函数） static修饰的成员变量称之为静态变量或者类变量。
2. static修饰的成员被所有的对象共享。
3. static优先于对象存在，因为static的成员随着类的加在就已经存在了
4. static修饰的成员多了一种调用方式，可以直接被类名所调用。
5. static修饰的数据是共享数据，对象中存储的是特有的数据

### 2、成员变量和静态变量的区别

1. 生命周期不同：

   成员变量随着对象的创建而存在随着对象的回收而释放。

   静态变量随着类的加载而存在随着类的消失而消失。

2. 调用方式不同：

   成员变量只有被对象调用。

   静态变量可以被对象调用，也可以用类名调用。(推荐使用类名调用)

3. 别名不同

   成员变量也称为实例变量。

   静态变量称为类变量。

4. 数据存储位置不同

   成员变量数据存储在堆内存中，所以也叫对象的特有数据。

   静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据。

###  3、静态使用时需要注意的事项

1. 静态方法只能访问静态成员(非静态可以访问静态，又可以访问非静态)。
2. 静态方法不可以使用this或者super关键字。
3. 主函数是静态的。

